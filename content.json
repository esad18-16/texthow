{"meta":{"title":"E18-16","subtitle":"","description":"","author":"Quan","url":"https://gitee.com/e18-16/texthow","root":"/texthow/"},"pages":[],"posts":[{"title":"学习记录","slug":"学习记录1","date":"2020-10-31T07:44:23.000Z","updated":"2020-11-08T14:57:18.559Z","comments":true,"path":"2020/10/31/学习记录1/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/31/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","excerpt":"","text":"无符号数（unsigned）在C语言中，如果一个运算包含一个有符号数和一个无符号数，那么C语言会隐式地将有符号数转换为无符号数，这对于标准的算术运算没什么问题，但是对于 &lt; 和 &gt; 这样的关系运算符来说，它会出现不是预料中的结果。#include &lt;stdio.h&gt;int main(void){ unsigned int a=6; int b=-20; (a+b&gt;6)?puts(“&gt;6”):puts(“&lt;=6”); printf(“%d\\n%d”,(a+b&gt;6),a+b); return 0;}运行结果： 61-14 ACM003： 查找缺失的元素描述：给定一个数组，找到其中的最大值n,输出[0,n]，在该数组中缺失的元素。输入：输入任意个自然数，当输入为-1时，结束输入。输出：输出缺失的元素，每两个元素之间用空格分隔。输入样例1 输出样例10 1 4 -1 2 3 当时的想法是直接对比每一个元素与其下标值，小则输出下标，没有如题目要求找最大值，再输出缺失元素。后再思考题目后，决定先找最大值，然后另设一个数组初始值为其对应下标，再将前一数组排序，一一对比，输出缺失元素。#include&lt;stdio.h&gt;int main(void){ int i; int a[10000]={0}; for(i=0;i&lt;10000&amp;&amp;a[i-1]!=-1;i++) //数组存储数，以-1为判定条件结束输入 { scanf(“%d”,&amp;a[i]); } int num=i; int j,s; for(i=0;i&lt;num;i++) //找出数组中的最大值 { for(j=i+1;j&lt;num;j++) { if(a[i]&lt;a[j]) s=a[j]; } } int z[s+1]; //另设一个数组，长度为a[]的最大值并初始化值为对应下标 for(j=0;j&lt;=s;j++) z[j]=j; int e; for(i=0;i&lt;num;i++) //将最大值前的数（冒泡）排序便于下一步排序 { for(j=i+1;j&lt;num;j++) { if(a[i]&gt;a[j]) { e=a[i]; a[i]=a[j]; a[j]=e; } } } j=0; int x; for(i=0;i&lt;=num;i++) //输出a数组关于0-最大值缺失的元素 { x=0; for(;j&lt;=s;j++) { if(a[i]&gt;z[j]) { printf(“%d “,z[j]); x++; } else break; } if(x!=0||j==0) //测试发现0需要特殊对待 j++; } return 0; } java:list、set、map的简单应用：public static void testlist() {// List sa=Arrays.asList(“11”,”07”,”18”,”16”); //初始化使用Arrays.asList(无法增减否则报错) List sa=new ArrayList() {{ add(\"11\"); //双括号大法好！就是效率会有损失，将list返回给其他地方使用时可能内存会有泄露 add(\"07\"); add(\"18\"); add(\"16\"); } }; System.out.println(sa); sa.add(1,\"20\"); //在sa[1]中加入元素20，元素后移 System.out.println(sa); sa.remove(2); //删除sa[2] System.out.println(sa); } public static void testmap() { Map m=new HashMap(){{ put(1, \"esd\"); put(2, \"esa\"); //双括号{{}}初始化hashmap put(3, \"rsf\"); }}; System.out.println(m); System.out.println(m.containsKey(2)); //输出键为2的值 System.out.println(m.containsValue(“rsf”)); //输出值为rsf的键 }public static void testset() { String[] shuzu=new String[10]; //初始化数组 for(int i=0;i&lt;10;i++) &#123; shuzu[i]= (&quot;&quot;+Math.round(Math.random()*5)); &#125; for(String temp: shuzu) System.out.print(temp+&quot; &quot;); System.out.println(); List aaa=Arrays.asList(shuzu); //将数组转化为list集合 System.out.println(aaa); Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(aaa); //将list转化为set集合对非重复元素进行筛选 System.out.println(set); &#125;","categories":[],"tags":[]},{"title":"题目记录","slug":"题目记录1","date":"2020-10-26T00:38:38.000Z","updated":"2020-11-08T10:59:58.168Z","comments":true,"path":"2020/10/26/题目记录1/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/26/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%951/","excerpt":"题目描述 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数示例1输入6输出2","text":"题目描述 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数示例1输入6输出2 代码实现如下： #include &lt;stdio.h&gt;int main(void){ int data; int count=0; scanf(“%d”,&amp;data); while(data) { count ++; data=data&amp;(data-1); } printf(“%d”, count); return 0;} 思路：初始只考虑了将输入数转换为二进制数存入数组，再一一检查数组中1的个数，既耗内存又耗时间。后来在网上查找其他解决方法，才知道位运算可以轻松解决这个问题。 实现文件读写操作文件写入后需要用rewind()函数使文件指针回到文件开头，不然后续的读入操作将会受影响。 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void){ FILE *fp; int num; int i; fp=fopen(“D:\\testfile.txt”,”wb+”); if(fp==NULL) { system(“color 2C”); printf(“Error!!!\\n”); } else { for(i=0;i&lt;5;i++) { scanf(“%d”,&amp;num); fprintf(fp,”%4d”,num); } } int s=0; rewind(fp); for(i=0;i&lt;5;i++) { if(1==fscanf(fp,”%d”,&amp;s)) printf(“%4d”,s); else { system(“color 47”); printf(“Error!!!\\n”); } } return 0; } 蓝桥杯b组2、3题：2既约分数:#include&lt;stdio.h&gt;int gongyue(int a,int b){ int i,min; if(a&gt;b) min=b; else min=a; for(i=min;i&gt;0;i–) { if((a%i==0)&amp;&amp;(b%i==0)) break; } return i;}int main(void){ int i=1; int num=0; for(;i&lt;=2020;i++) { int j=1; for(;j&lt;=2020;j++) { if(gongyue(i,j)==1) num++; } } printf(“%d”,num); return 0;} 3蛇形填数:#include&lt;stdio.h&gt;int main(void){ int i=1; int j=0; int a[50][50]; a[0][0]=1; a[0][1]=2; a[1][0]=3; for(int num=3;num&lt;50*25;) { if(i==0&amp;&amp;j!=0) { a[i][j+1]=a[i][j]+1; j++; num++; } if(j==0&amp;&amp;i!=0) { a[i+1][j]=a[i][j]+1; i++; num++; } if(i!=0&amp;&amp;j==0) { while(i!=0) { a[i-1][j+1]=a[i][j]+1; i–; j++; num++; } continue; } if(i==0&amp;&amp;j!=0) { while(j!=0) { a[i+1][j-1]=a[i][j]+1; i++; j–; num++; } continue; } } printf(“%d\\n”,a[19][19]); return 0;}","categories":[],"tags":[]},{"title":"First blog","slug":"The-First-blog","date":"2020-10-19T07:53:43.196Z","updated":"2020-10-26T11:10:27.716Z","comments":true,"path":"2020/10/19/The-First-blog/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/19/The-First-blog/","excerpt":"散列表查找操作","text":"散列表查找操作 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10 //最大存储单元数typedef int keytype;typedef keytype HTable[MAXSIZE]; void creatHT(HTable HT,int m,int p){ int i,n=0; //n记录散列表中的元素个数 keytype x; //x存放关键字 printf(“请输入关键字(-999为结束输入数，最大存储单元为10)：\\n”); scanf(“%d”,&amp;x); while(x!=-999&amp;&amp;i&lt;MAXSIZE+1) { n++; if(n&gt;m) break; i=x%p; while(HT[i]!=-999) //判断是否有冲突,有则进行线性探测 i=(++i)%m; HT[i]=x; scanf(“%d”,&amp;x); }} void display(HTable HT,int m){ int i,j=0; for(i=0;i&lt;MAXSIZE;i++) //先输出地址便于查看 { if(i==0) printf(“ 地址：”); printf(“%4d”,i); } printf(“\\n”); for(i=0;i&lt;MAXSIZE;i++) //输出关键字 { if(i==0) printf(“关键字：”); if(HT[i]!=-999) { printf(“%4d”,HT[i]); j++; } else printf(“ “); if(j==m) break; } printf(“\\n”);} void search(HTable HT,int m,int p){ int i,j,x,s=0; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; j=i; while(HT[j]!=-999) { if(HT[j]==x) { printf(“关键字已找到，在数组中的下标为%d\\n”,j); s++; } //找到后输出j j=(j+1)%m; if(j==i) break; //没找到退出循环 } if(s==0) printf(“表中没有该关键字！\\n”);} int main(void){ HTable HT; int i; printf(“请先创建哈希表：\\n”); for(i=0;i&lt;MAXSIZE;i++) //初始化散列表 HT[i]=-999; creatHT(HT,MAXSIZE,MAXSIZE); display(HT,MAXSIZE); search(HT,MAXSIZE,MAXSIZE); return 0;} 四、2：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int key;typedef struct node{ key data; //存放关键字 struct node *next;}slink; void creat(slink *h[],int m,int p) //m为表长，p为除数{ int i; key x; slink *s; for(i=0;i&lt;m;i++) //初始化 h[i]=NULL; printf(“请输入关键字(-999为结束输入数)：\\n”); scanf(“%d”,&amp;x); while(x!=-999) { i=x%p; s=(slink *)malloc(sizeof(slink)); s-&gt;data=x; s-&gt;next=h[i]; //首插法 h[i]=s; scanf(“%d”,&amp;x); } } void display(slink *h[],int m){ int i; slink *s; printf(“地址 关键字\\n”); //控制输出格式便于观看 for(i=0;i&lt;m;i++) { printf(“%-4d “,i); s=h[i]; for(;s;s=s-&gt;next) printf(“%-4d”,s-&gt;data); printf(“\\n”); }} void search(slink *h[],int p){ slink *q; int i,j=0; key x; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; q=h[i]; while(q) { if(q-&gt;data==x) { printf(“关键字已找到,在下标为%d的链表中\\n”,i); j++; break; } q=q-&gt;next; } if(j==0) { printf(“未找到！！！\\n”); }} int main(void){ int m; printf(“请先创建哈希表：\\n”); printf(“请输入关键字长度：\\n”); scanf(“%d”,&amp;m); slink *h[m]; creat(h,m,m); display(h,m); search(h,m); return 0;} 实验内容1．闭散列表（也称开地址方法）查找的实现2．开散列表（也称拉链法）查找的实现 1：该实验的目的为“闭散列表（也称开地址方法）查找的实现”，所以我选择建立一个数组来保存关键字，散列函数构造用了除留余数法，并设置表长与除数一致，其中又选择了线性探测再散列的方法解决冲突。2：该实验的目的为散列表（也称拉链法）查找的实现，在实验中我曾定义了一个结构体指针变量传给结构体指针数组，导致溢出，编译和结果没问题但是出现return value 3221225477，更改之后一切正常了。","categories":[],"tags":[]}],"categories":[],"tags":[]}