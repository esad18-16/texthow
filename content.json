{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://gitee.com/e18-16/texthow","root":"/"},"pages":[],"posts":[{"title":"First blog","slug":"The-First-blog","date":"2020-10-19T07:53:43.196Z","updated":"2020-10-19T13:55:40.089Z","comments":true,"path":"2020/10/19/The-First-blog/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/19/The-First-blog/","excerpt":"","text":"散列表查找操作#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10 //最大存储单元数typedef int keytype;typedef keytype HTable[MAXSIZE]; void creatHT(HTable HT,int m,int p){ int i,n=0; //n记录散列表中的元素个数 keytype x; //x存放关键字 printf(“请输入关键字(-999为结束输入数，最大存储单元为10)：\\n”); scanf(“%d”,&amp;x); while(x!=-999&amp;&amp;i&lt;MAXSIZE+1) { n++; if(n&gt;m) break; i=x%p; while(HT[i]!=-999) //判断是否有冲突,有则进行线性探测 i=(++i)%m; HT[i]=x; scanf(“%d”,&amp;x); }} void display(HTable HT,int m){ int i,j=0; for(i=0;i&lt;MAXSIZE;i++) //先输出地址便于查看 { if(i==0) printf(“ 地址：”); printf(“%4d”,i); } printf(“\\n”); for(i=0;i&lt;MAXSIZE;i++) //输出关键字 { if(i==0) printf(“关键字：”); if(HT[i]!=-999) { printf(“%4d”,HT[i]); j++; } else printf(“ “); if(j==m) break; } printf(“\\n”);} void search(HTable HT,int m,int p){ int i,j,x,s=0; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; j=i; while(HT[j]!=-999) { if(HT[j]==x) { printf(“关键字已找到，在数组中的下标为%d\\n”,j); s++; } //找到后输出j j=(j+1)%m; if(j==i) break; //没找到退出循环 } if(s==0) printf(“表中没有该关键字！\\n”);} int main(void){ HTable HT; int i; printf(“请先创建哈希表：\\n”); for(i=0;i&lt;MAXSIZE;i++) //初始化散列表 HT[i]=-999; creatHT(HT,MAXSIZE,MAXSIZE); display(HT,MAXSIZE); search(HT,MAXSIZE,MAXSIZE); return 0;} 四、2：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int key;typedef struct node{ key data; //存放关键字 struct node *next;}slink; void creat(slink *h[],int m,int p) //m为表长，p为除数{ int i; key x; slink *s; for(i=0;i&lt;m;i++) //初始化 h[i]=NULL; printf(“请输入关键字(-999为结束输入数)：\\n”); scanf(“%d”,&amp;x); while(x!=-999) { i=x%p; s=(slink *)malloc(sizeof(slink)); s-&gt;data=x; s-&gt;next=h[i]; //首插法 h[i]=s; scanf(“%d”,&amp;x); } } void display(slink *h[],int m){ int i; slink *s; printf(“地址 关键字\\n”); //控制输出格式便于观看 for(i=0;i&lt;m;i++) { printf(“%-4d “,i); s=h[i]; for(;s;s=s-&gt;next) printf(“%-4d”,s-&gt;data); printf(“\\n”); }} void search(slink *h[],int p){ slink *q; int i,j=0; key x; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; q=h[i]; while(q) { if(q-&gt;data==x) { printf(“关键字已找到,在下标为%d的链表中\\n”,i); j++; break; } q=q-&gt;next; } if(j==0) { printf(“未找到！！！\\n”); }} int main(void){ int m; printf(“请先创建哈希表：\\n”); printf(“请输入关键字长度：\\n”); scanf(“%d”,&amp;m); slink *h[m]; creat(h,m,m); display(h,m); search(h,m); return 0;} 实验内容1．闭散列表（也称开地址方法）查找的实现2．开散列表（也称拉链法）查找的实现 1：该实验的目的为“闭散列表（也称开地址方法）查找的实现”，所以我选择建立一个数组来保存关键字，散列函数构造用了除留余数法，并设置表长与除数一致，其中又选择了线性探测再散列的方法解决冲突。2：该实验的目的为散列表（也称拉链法）查找的实现，在实验中我曾定义了一个结构体指针变量传给结构体指针数组，导致溢出，编译和结果没问题但是出现return value 3221225477，更改之后一切正常了。","categories":[],"tags":[]}],"categories":[],"tags":[]}