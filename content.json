{"meta":{"title":"E18-16","subtitle":"","description":"","author":"Quan","url":"https://gitee.com/e18-16/texthow","root":"/texthow/"},"pages":[],"posts":[{"title":"学习记录9","slug":"学习记录9","date":"2021-04-25T14:58:04.000Z","updated":"2021-04-25T15:00:42.778Z","comments":true,"path":"2021/04/25/学习记录9/","link":"","permalink":"https://gitee.com/e18-16/texthow/2021/04/25/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%959/","excerpt":"","text":"蓝桥杯A、空间小蓝准备用 256MB 的内存空间开一个数组，数组的每个元素都是 32 位二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问256MB 的空间可以存储多少个 32 位二进制整数？ 直接敲计算机 (25610241024)/4 B、卡片【问题描述】小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从 1 拼到多少。例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1拼到多少？提示：建议使用计算机编程解决问题。分析题目可知1是用的最多的数字，所以只需要计算1的个数即可，由于1900个1可拼到3000，所以设定从3000开始暴力循环推算即可。结果为3181代码实现如下： #include int main(void) &#123; int i=1900; int k=3000; while(i=2021) &#123; printf(\"%d\",k); return 0; &#125; &#125; if(b==1) &#123; i++; if(i>=2021) &#123; printf(\"%d\",k); return 0; &#125; &#125; if(c==1) &#123; i++; if(i>=2021) &#123; printf(\"%d\",k); return 0; &#125; &#125; &#125; return 0; &#125; I、双向排序【问题描述】给定序列 (a1, a2, · · · , an) = (1, 2, · · · , n)，即 ai = i。小蓝将对这个序列进行 m 次操作，每次可能是将 a1, a2, · · · , aqi 降序排列，或者将 aqi , aqi+1, · · · , an 升序排列。请求出操作完成后的序列。【输入格式】输入的第一行包含两个整数 n, m，分别表示序列的长度和操作次数。接下来 m 行描述对序列的操作，其中第 i 行包含两个整数 pi, qi 表示操作类型和参数。当 pi = 0 时，表示将 a1, a2, · · · , aqi 降序排列；当 pi = 1 时，表示将 aqi , aqi+1, · · · , an 升序排列。【输出格式】输出一行，包含 n 个整数，相邻的整数之间使用一个空格分隔，表示操作完成后的序列。【样例输入】3 30 31 20 2【样例输出】3 1 2【样例说明】原数列为 (1, 2, 3)。 第 1 步后为 (3, 2, 1)。 第 2 步后为 (3, 1, 2)。 第 3 步后为 (3, 1, 2)。与第 2 步操作后相同，因为前两个数已经是降序了。【评测用例规模与约定】对于 30% 的评测用例，n, m ≤ 1000；对于 60% 的评测用例，n, m ≤ 5000；对于所有评测用例，1 ≤ n, m ≤ 100000，0 ≤ ai ≤ 1，1 ≤ bi ≤ n。目前只写了冒泡法排序的，所耗的时间较多，其他的排序还不熟练，会继续更进的。代码如下： #include #include void up(int a[],int low,int high) &#123; int i,j,temp; int s=0; for(i=low;i","categories":[],"tags":[]},{"title":"学习记录8","slug":"学习记录8","date":"2020-12-27T12:28:06.000Z","updated":"2020-12-27T12:40:49.806Z","comments":true,"path":"2020/12/27/学习记录8/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/12/27/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%958/","excerpt":"","text":"传智杯初赛题1：题目：解题思路：设置两个参数j、num，j用来记录已经报名了多少个学员到达m个时回到0，num记录费用，直接使用for循环以n为结束标志，当j与m相等时价格v+=a。AC代码如下： #includeint main(void)&#123; int n,v,m,a; while(scanf(\"%d %d %d %d\",&n,&v,&m,&a)!=EOF) &#123; int i,j=0,num=0; for(i=0;i=90) &#123; printf(\"4.0\\n\"); continue; &#125; if(n>=60&&n","categories":[],"tags":[]},{"title":"学习记录7","slug":"学习记录7","date":"2020-12-21T07:42:13.000Z","updated":"2020-12-27T12:33:44.131Z","comments":true,"path":"2020/12/21/学习记录7/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/12/21/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957/","excerpt":"JAVA文件读取:按字符读取：FileReader.read(char[] cbuf),参数是目标缓冲区，返回读取的字符数量，如果已经达到文件末尾返回-1.按行读取:BufferReader.readline(),没有参数，返回该行字符串，不包含行终止符，如已达末尾返回null窗口关闭：dispose() 仅仅释放窗体资源,而不会关闭主线程 这周忙着弄实验啥的，没学啥，都还在收藏夹没有整理，传智杯的也没有整理完下次再发传智杯的(-.-)","text":"JAVA文件读取:按字符读取：FileReader.read(char[] cbuf),参数是目标缓冲区，返回读取的字符数量，如果已经达到文件末尾返回-1.按行读取:BufferReader.readline(),没有参数，返回该行字符串，不包含行终止符，如已达末尾返回null窗口关闭：dispose() 仅仅释放窗体资源,而不会关闭主线程 这周忙着弄实验啥的，没学啥，都还在收藏夹没有整理，传智杯的也没有整理完下次再发传智杯的(-.-) 力扣49：首先设置二维list表，用于return，然后设置一维的list用来添加到二维的中，再设置一维数组用来存储每个字符串的大小，然后进行循环判断，如果其中没有字符串的大小相等那么直接添加到二维链表中，如果有相同大小的，将字符串按从小到大的次序排好，再比较字符串是否相等，相等就添加到一维链表中，其中设置记录，如果已进入链表的，将数组的大小定为-9999，循环到直接跳过。（做完后看到官方的，才知道直接计字符串出现次数比较即可，我的时间利用率太低了。。。）题目：运行结果： 代码： class Solution &#123; public List groupAnagrams(String[] strs) &#123; List ll=new ArrayList(); int[] num=new int[strs.length]; int sum; for(int i=0;i","categories":[],"tags":[]},{"title":"学习记录6","slug":"学习记录6","date":"2020-12-14T12:57:10.000Z","updated":"2020-12-21T07:42:29.929Z","comments":true,"path":"2020/12/14/学习记录6/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/12/14/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956/","excerpt":"抽象方法：使用abstract修饰的方法，没有方法体，只有声明。必须由子类实现抽象类： 1、有抽象方法的类只能定义成抽象类 2、抽象类不能实例化 3、抽象类可以包含属性、方法、构造器，但是构造器只能用来被子类调用 4、抽象类只能用来被继承 接口（interface）： 1、访问修饰符只能是public或默认设置（default） 2、接口可以多继承 3、属性只能是常量（public static final修饰） 4、方法只能是public abstract 5、子类通过implement来实现接口的“规范” 6、不能实例化","text":"抽象方法：使用abstract修饰的方法，没有方法体，只有声明。必须由子类实现抽象类： 1、有抽象方法的类只能定义成抽象类 2、抽象类不能实例化 3、抽象类可以包含属性、方法、构造器，但是构造器只能用来被子类调用 4、抽象类只能用来被继承 接口（interface）： 1、访问修饰符只能是public或默认设置（default） 2、接口可以多继承 3、属性只能是常量（public static final修饰） 4、方法只能是public abstract 5、子类通过implement来实现接口的“规范” 6、不能实例化 内部类： 1、可以使用public、default、protected、private、static来修饰（外部类只能由public、default修饰） 2、提供了更好的封装，只能由外部类直接访问 3、可以直接访问外部类的私有属性，但外部类不能访问内部类的内部属性 4、使多重继承的解决方案更完整 5、访问要点：内部类属性：this.变量名，外部类属性：外部类名.this.变量名，在外部类中定义内部类：new Inner()，在外部类以外的地方使用非静态内部类：Outer.Inner varname=new Outer.new Inner(); String:JAVA中可以使用“+”运算符将两个字符串连接，并且当其中由String类型时，系统将自动将另一个操作数转换为字符串再连接。判断字符串相等使用equal（）不用==String详解：https://blog.csdn.net/weixin_41477980/article/details/85109179?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160791182519195283096493%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160791182519195283096493&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-85109179.nonecase&amp;utm_term=java%20String&amp;spm=1018.2118.3001.4449 力扣2先设置两个链表一个用来存储相加后的数据，一个用来记录链表头部便以返回，然后将传过来的链表一一对应相加，有超于10的就将i复赋值为1，然后减10存储到链表中，通过判断i是否为1，下一步再是否加1。一共会有两种情况，一：两个链表长度一致，对应加起来即可，检测最后i是否为1，为1链表就要再创一个next然后加1即可。二：两个链表长度不一致，先将长度短的加完，然后再判断i是否为1，为0直接将剩余的链表依次赋值，为1就按之前步骤一样一步一步判断相加。题目：运行结果：代码如下:class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode l3 =new ListNode(0); ListNode l4=l3; int x=0,i=0; while(l1!=null&amp;&amp;l2!=null) { if(i==0) x=l1.val+l2.val; else x=l1.val+l2.val+1; if(x&gt;9) { l3.val=x-10; i=1; } else { l3.val=x; i=0; } l1=l1.next; l2=l2.next; if(l1==null||l2==null) break; l3.next=new ListNode(0); l3=l3.next; &#125; while(l1==null&amp;&amp;l2!=null) &#123; l3.next=new ListNode(0) ; l3=l3.next; if(i==1) if(l2.val+1&gt;9) &#123; l3.val=l2.val+1-10; i=1; &#125; else&#123; l3.val=l2.val+1; i=0; &#125; else if(i==0) &#123; l3.val=l2.val; i=0; &#125; l2=l2.next; &#125; while(l1!=null&amp;&amp;l2==null) &#123; l3.next=new ListNode(0) ; l3=l3.next; if(i==1) if(l1.val+1&gt;9) &#123; l3.val=l1.val+1-10; i=1; &#125; else&#123; l3.val=l1.val+1; i=0; &#125; else if(i==0) &#123; l3.val=l1.val; i=0; &#125; l1=l1.next; &#125; if(i==1) &#123; l3.next=new ListNode(0) ; l3=l3.next; l3.val=1; &#125; return l4; &#125; }","categories":[],"tags":[]},{"title":"学习记录5","slug":"学习记录5","date":"2020-12-07T10:44:08.000Z","updated":"2020-12-21T07:01:46.053Z","comments":true,"path":"2020/12/07/学习记录5/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/12/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955/","excerpt":"EOF是End Of File 的缩写，是c语言中标准库中定义的宏，定义为：#define EOF (-1)；EOF的值为-1，是int类型数据，在32位系统中，可以表示为0xFFFFFFFF; EOF 不是一个字符，也不是文件中实际存在的内容。EOF不但能表示读文件到了结尾这一状态，它还能表示 I/O 操作中的读、写错误（可以用 ferror() 来检测）以及其它一些关联操作的错误状态 (详情参考：https://blog.csdn.net/flyyyri/article/details/5084981?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control)","text":"EOF是End Of File 的缩写，是c语言中标准库中定义的宏，定义为：#define EOF (-1)；EOF的值为-1，是int类型数据，在32位系统中，可以表示为0xFFFFFFFF; EOF 不是一个字符，也不是文件中实际存在的内容。EOF不但能表示读文件到了结尾这一状态，它还能表示 I/O 操作中的读、写错误（可以用 ferror() 来检测）以及其它一些关联操作的错误状态 (详情参考：https://blog.csdn.net/flyyyri/article/details/5084981?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control) Java-GUIJFrame()创建一个初始时不可见的窗口JFrame(String title)创建一个标题为title且初始时不可见的窗口JFrame.getContentPane().setBackground(Color.c)改变窗口颜色（setBackground()方法继承自Frame,直接使用无效）setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)设置窗口关闭模式JPanel(LayoutManager layout) 以指定的布局管理器创建面板，默认流式布局 力扣861 题目：题解：初始没有啥思路，果断跑去看题解学习，得出思路是：先判断每一行首位是否为零，若不为零则移动该行，因为在二进制中第一位数比后面的数都大，考虑第一位是否为零即可，然后判断除第一列的其他列中的零的数目是否大于一的数目，若大则移动该列，其中用一个数记录可得出所要结果。还有做了一些acm的小题就懒得放上来了","categories":[],"tags":[]},{"title":"学习记录4","slug":"学习记录4","date":"2020-11-29T12:23:25.000Z","updated":"2020-12-07T10:44:31.681Z","comments":true,"path":"2020/11/29/学习记录4/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/11/29/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954/","excerpt":"利用string库函数的strcpy复制、strcat拼接、strcmp比较即可完成","text":"利用string库函数的strcpy复制、strcat拼接、strcmp比较即可完成 C语言中函数返回字符串的四种方法：1、 将字符串指针作为函数参数传入，并返回该指针。2、 使用malloc函数动态分配内存，注意在主调函数中释放。3、 返回一个静态局部变量。采用了静态局部变量（位于静态区，程序结束时由系统进行释放），这就导致，如果多次调用这个函数，下一次调用会将上一次调用的结果覆盖掉。4、 使用全局变量。 目前看题只想到了根据给的数n,k,先将总数k拆由k/n所得的平均数进一个数组，余数存在就一一从尾开始分开，如果余数大于26就一一从尾分进数组，否则直接加到数组最后一个中，再通过循环一一确定好字典序（把数组前面的数转到后面去）。","categories":[],"tags":[]},{"title":"学习记录3.","slug":"学习记录3","date":"2020-11-22T14:25:01.000Z","updated":"2020-11-29T12:35:01.901Z","comments":true,"path":"2020/11/22/学习记录3/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/11/22/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/","excerpt":"this关键字：this关键字代表了所属函数的调用者对象。(哪个对象调用这个函数，this就代表哪个对象)如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)在一个构造函数中可以调用另外一个构造函数初始化对象。","text":"this关键字：this关键字代表了所属函数的调用者对象。(哪个对象调用这个函数，this就代表哪个对象)如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)在一个构造函数中可以调用另外一个构造函数初始化对象。 this关键字调用其他的构造函数时，this关键字必须要位于构造函数中的第一个语句。This不能用于静态方法种this关键字在构造函数中不能出现相互调用的情况，因为是一个死循环。详情参考“this关键字、this关键字应用 (csdn.net)” 参数值传递机制：基本数据类型参数传递的是值的副本，副本改变不会影响原件。引用数据类型参数传递的也是值的副本，但是引用类型指的是对象的地址，因此改变副本的值，原件也会改变。 Instanceof运算符： ( s Instanceof Person) 左边为对象，右边为类 当左边的对象为右边类或子类创建对象时返回ture，否则为false。 继承：1、Java只有单继承，但接口有多继承。2、子类继承父类可以得到父类的所有方法和属性（除了父类的构造器）,但是不一定可以直接访问（例如父类的私有属性和方法）。3、定义类时没有调用extends默认父类为java.lang.Object. 方法的重写的条件：1、方法名、形参列表相同。2、返回值类型和声明异常类型，子类小于等于父类。3、访问权限，子类大于等于父类 （封装）访问控制符：private：只有自己的类可以访问default(默认修饰符)：只能访问同一个包中的类protected：可以被同一个包的类以及其他包的子类访问public：可以被项目中的所有包中的所有类访问 ACM005：初始时直接使用递归，上交OJ后，判定内存超出限制，之后在题目的讨论中发现要利用周期减少内存使用，利用周期便可AC#include&lt;stdio.h&gt;int calculate(int a,int b,int c){ if(c&gt;49) //49为一个周期 c%=49; if(c==2||c==1) return 1; else return ((acalculate(a,b,c-1)+bcalculate(a,b,c-2))%7);}int main(void){ int a,b,n; scanf(“%d %d %d”,&amp;a,&amp;b,&amp;n); while(a!=0&amp;&amp;b!=0&amp;n!=0) { printf(&quot;%d\\n&quot;,calculate(a,b,n)); scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;n); &#125; return 0; }","categories":[],"tags":[]},{"title":"学习记录2","slug":"学习记录2","date":"2020-11-15T09:49:44.000Z","updated":"2020-11-22T13:50:29.230Z","comments":true,"path":"2020/11/15/学习记录2/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/11/15/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/","excerpt":"位、字节、字（bits, Bytes, words）是计算机数据存储的单位。位是最小的存储单位，每一个位存储一个1位的二进制码，一个字节由8位组成。而字通常为16、32或64个位组成。 Java：类型 byte short char int float long double所占字节 1 2 2 4 4 8 8","text":"位、字节、字（bits, Bytes, words）是计算机数据存储的单位。位是最小的存储单位，每一个位存储一个1位的二进制码，一个字节由8位组成。而字通常为16、32或64个位组成。 Java：类型 byte short char int float long double所占字节 1 2 2 4 4 8 8 局部变量使用前要声明初始化，成员变量和静态变量如不自行初始化，系统会给予默认初始值，如下：类型 int double char Boolean初始值 0 0.0 ‘\\u0000’ false 常量定义格式： final type vername =value; (例：final PI = 3.14;) 一旦初始化后不可更改值 引用数据类型的大小为4个字节，记录的是引用对象的地址。 浮点数比较时使用BigDecimal类 二元运算规则：整数运算时，两个操作数有long，则结果为long。没有时都是int浮点运算时，有double，结果就是double，只有两个操作数都是float，才为float BigInteger类的常用方法：public BigInteger add(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的和public BigInteger subtract(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的差public BigInteger multiply(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的积public BigInteger devide(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的商public BigInteger remainder(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的余public int compareTo(BigInteger val) 返回当前大整数对象与参数指定的大整数对象的比较结果，返回值是1、-1、0，分别表示当前大整数对象大于、小于或等于参数指定的大整数。public BigInteger abs() 返回当前大整数对象的绝对值public BigInteger pow(int exponent) 返回当前大整数对象的exponent次幂。public String toString() 返回当前当前大整数对象十进制的字符串表示。public String toString(int p) 返回当前大整数对象p进制的字符串表示。 ACM1002记录： import java.math.BigInteger;import java.util.Scanner;public class Acm1002 { public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for(int i=1; i&lt;=n; i++) &#123; BigInteger a = sc.nextBigInteger(); BigInteger b = sc.nextBigInteger(); BigInteger sum = a.add(b); System.out.println(&quot;Case &quot;+i+&quot;:&quot;); System.out.println(a +&quot; + &quot; + b +&quot; = &quot;+sum); if(i!=n) System.out.println(); &#125; &#125; }","categories":[],"tags":[]},{"title":"学习记录","slug":"学习记录1","date":"2020-10-31T07:44:23.000Z","updated":"2020-11-15T10:08:39.806Z","comments":true,"path":"2020/10/31/学习记录1/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/31/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","excerpt":"无符号数（unsigned）在C语言中，如果一个运算包含一个有符号数和一个无符号数，那么C语言会隐式地将有符号数转换为无符号数，这对于标准的算术运算没什么问题，但是对于 &lt; 和 &gt; 这样的关系运算符来说，它会出现不是预料中的结果。","text":"无符号数（unsigned）在C语言中，如果一个运算包含一个有符号数和一个无符号数，那么C语言会隐式地将有符号数转换为无符号数，这对于标准的算术运算没什么问题，但是对于 &lt; 和 &gt; 这样的关系运算符来说，它会出现不是预料中的结果。 #include &lt;stdio.h&gt;int main(void){ unsigned int a=6; int b=-20; (a+b&gt;6)?puts(“&gt;6”):puts(“&lt;=6”); printf(“%d\\n%d”,(a+b&gt;6),a+b); return 0;}运行结果：/&gt;61-14 ACM003： 查找缺失的元素描述：给定一个数组，找到其中的最大值n,输出[0,n]，在该数组中缺失的元素。输入：输入任意个自然数，当输入为-1时，结束输入。输出：输出缺失的元素，每两个元素之间用空格分隔。输入样例1 输出样例10 1 4 -1 2 3 当时的想法是直接对比每一个元素与其下标值，小则输出下标，没有如题目要求找最大值，再输出缺失元素。后再思考题目后，决定先找最大值，然后另设一个数组初始值为其对应下标，再将前一数组排序，一一对比，输出缺失元素。#include&lt;stdio.h&gt;int main(void){ int i; int a[10000]={0}; for(i=0;i&lt;10000&amp;&amp;a[i-1]!=-1;i++) //数组存储数，以-1为判定条件结束输入 { scanf(“%d”,&amp;a[i]); } int num=i; int j,s; for(i=0;i&lt;num;i++) //找出数组中的最大值 { for(j=i+1;j&lt;num;j++) { if(a[i]&lt;a[j]) s=a[j]; } } int z[s+1]; //另设一个数组，长度为a[]的最大值并初始化值为对应下标 for(j=0;j&lt;=s;j++) z[j]=j; int e; for(i=0;i&lt;num;i++) //将最大值前的数（冒泡）排序便于下一步排序 { for(j=i+1;j&lt;num;j++) { if(a[i]&gt;a[j]) { e=a[i]; a[i]=a[j]; a[j]=e; } } } j=0; int x; for(i=0;i&lt;=num;i++) //输出a数组关于0-最大值缺失的元素 { x=0; for(;j&lt;=s;j++) { if(a[i]&gt;z[j]) { printf(“%d “,z[j]); x++; } else break; } if(x!=0||j==0) //测试发现0需要特殊对待 j++; } return 0; } java:list、set、map的简单应用：public class Testgenerics { public static void testlist() {// List sa=Arrays.asList(“11”,”07”,”18”,”16”); //初始化使用Arrays.asList(无法增减否则报错) List sa=new ArrayList() {{ add(\"11\"); //双括号大法好！就是效率会有损失，将list返回给其他地方使用时可能内存会有泄露 add(\"07\"); add(\"18\"); add(\"16\"); } }; System.out.println(sa); sa.add(1,\"20\"); //在sa[1]中加入元素20，元素后移 System.out.println(sa); sa.remove(2); //删除sa[2] System.out.println(sa); } public static void testmap() { Map m=new HashMap(){{ put(1, \"esd\"); put(2, \"esa\"); //双括号{{}}初始化hashmap put(3, \"rsf\"); }}; System.out.println(m); System.out.println(m.containsKey(2)); //输出键为2的值 System.out.println(m.containsValue(“rsf”)); //输出值为rsf的键 } public static void testset() &#123; String[] shuzu=new String[10]; //初始化数组 for(int i=0;i&lt;10;i++) &#123; shuzu[i]= (&quot;&quot;+Math.round(Math.random()*5)); &#125; for(String temp: shuzu) System.out.print(temp+&quot; &quot;); System.out.println(); List aaa=Arrays.asList(shuzu); //将数组转化为list集合 System.out.println(aaa); Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(aaa); //将list转化为set集合对非重复元素进行筛选 System.out.println(set); &#125; }","categories":[],"tags":[]},{"title":"题目记录","slug":"题目记录1","date":"2020-10-26T00:38:38.000Z","updated":"2020-11-08T10:59:58.168Z","comments":true,"path":"2020/10/26/题目记录1/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/26/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%951/","excerpt":"题目描述 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数示例1输入6输出2","text":"题目描述 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数示例1输入6输出2 代码实现如下： #include &lt;stdio.h&gt;int main(void){ int data; int count=0; scanf(“%d”,&amp;data); while(data) { count ++; data=data&amp;(data-1); } printf(“%d”, count); return 0;} 思路：初始只考虑了将输入数转换为二进制数存入数组，再一一检查数组中1的个数，既耗内存又耗时间。后来在网上查找其他解决方法，才知道位运算可以轻松解决这个问题。 实现文件读写操作文件写入后需要用rewind()函数使文件指针回到文件开头，不然后续的读入操作将会受影响。 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void){ FILE *fp; int num; int i; fp=fopen(“D:\\testfile.txt”,”wb+”); if(fp==NULL) { system(“color 2C”); printf(“Error!!!\\n”); } else { for(i=0;i&lt;5;i++) { scanf(“%d”,&amp;num); fprintf(fp,”%4d”,num); } } int s=0; rewind(fp); for(i=0;i&lt;5;i++) { if(1==fscanf(fp,”%d”,&amp;s)) printf(“%4d”,s); else { system(“color 47”); printf(“Error!!!\\n”); } } return 0; } 蓝桥杯b组2、3题：2既约分数:#include&lt;stdio.h&gt;int gongyue(int a,int b){ int i,min; if(a&gt;b) min=b; else min=a; for(i=min;i&gt;0;i–) { if((a%i==0)&amp;&amp;(b%i==0)) break; } return i;}int main(void){ int i=1; int num=0; for(;i&lt;=2020;i++) { int j=1; for(;j&lt;=2020;j++) { if(gongyue(i,j)==1) num++; } } printf(“%d”,num); return 0;} 3蛇形填数:#include&lt;stdio.h&gt;int main(void){ int i=1; int j=0; int a[50][50]; a[0][0]=1; a[0][1]=2; a[1][0]=3; for(int num=3;num&lt;50*25;) { if(i==0&amp;&amp;j!=0) { a[i][j+1]=a[i][j]+1; j++; num++; } if(j==0&amp;&amp;i!=0) { a[i+1][j]=a[i][j]+1; i++; num++; } if(i!=0&amp;&amp;j==0) { while(i!=0) { a[i-1][j+1]=a[i][j]+1; i–; j++; num++; } continue; } if(i==0&amp;&amp;j!=0) { while(j!=0) { a[i+1][j-1]=a[i][j]+1; i++; j–; num++; } continue; } } printf(“%d\\n”,a[19][19]); return 0;}","categories":[],"tags":[]},{"title":"First blog","slug":"The-First-blog","date":"2020-10-19T07:53:43.196Z","updated":"2020-10-26T11:10:27.716Z","comments":true,"path":"2020/10/19/The-First-blog/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/19/The-First-blog/","excerpt":"散列表查找操作","text":"散列表查找操作 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10 //最大存储单元数typedef int keytype;typedef keytype HTable[MAXSIZE]; void creatHT(HTable HT,int m,int p){ int i,n=0; //n记录散列表中的元素个数 keytype x; //x存放关键字 printf(“请输入关键字(-999为结束输入数，最大存储单元为10)：\\n”); scanf(“%d”,&amp;x); while(x!=-999&amp;&amp;i&lt;MAXSIZE+1) { n++; if(n&gt;m) break; i=x%p; while(HT[i]!=-999) //判断是否有冲突,有则进行线性探测 i=(++i)%m; HT[i]=x; scanf(“%d”,&amp;x); }} void display(HTable HT,int m){ int i,j=0; for(i=0;i&lt;MAXSIZE;i++) //先输出地址便于查看 { if(i==0) printf(“ 地址：”); printf(“%4d”,i); } printf(“\\n”); for(i=0;i&lt;MAXSIZE;i++) //输出关键字 { if(i==0) printf(“关键字：”); if(HT[i]!=-999) { printf(“%4d”,HT[i]); j++; } else printf(“ “); if(j==m) break; } printf(“\\n”);} void search(HTable HT,int m,int p){ int i,j,x,s=0; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; j=i; while(HT[j]!=-999) { if(HT[j]==x) { printf(“关键字已找到，在数组中的下标为%d\\n”,j); s++; } //找到后输出j j=(j+1)%m; if(j==i) break; //没找到退出循环 } if(s==0) printf(“表中没有该关键字！\\n”);} int main(void){ HTable HT; int i; printf(“请先创建哈希表：\\n”); for(i=0;i&lt;MAXSIZE;i++) //初始化散列表 HT[i]=-999; creatHT(HT,MAXSIZE,MAXSIZE); display(HT,MAXSIZE); search(HT,MAXSIZE,MAXSIZE); return 0;} 四、2：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int key;typedef struct node{ key data; //存放关键字 struct node *next;}slink; void creat(slink *h[],int m,int p) //m为表长，p为除数{ int i; key x; slink *s; for(i=0;i&lt;m;i++) //初始化 h[i]=NULL; printf(“请输入关键字(-999为结束输入数)：\\n”); scanf(“%d”,&amp;x); while(x!=-999) { i=x%p; s=(slink *)malloc(sizeof(slink)); s-&gt;data=x; s-&gt;next=h[i]; //首插法 h[i]=s; scanf(“%d”,&amp;x); } } void display(slink *h[],int m){ int i; slink *s; printf(“地址 关键字\\n”); //控制输出格式便于观看 for(i=0;i&lt;m;i++) { printf(“%-4d “,i); s=h[i]; for(;s;s=s-&gt;next) printf(“%-4d”,s-&gt;data); printf(“\\n”); }} void search(slink *h[],int p){ slink *q; int i,j=0; key x; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; q=h[i]; while(q) { if(q-&gt;data==x) { printf(“关键字已找到,在下标为%d的链表中\\n”,i); j++; break; } q=q-&gt;next; } if(j==0) { printf(“未找到！！！\\n”); }} int main(void){ int m; printf(“请先创建哈希表：\\n”); printf(“请输入关键字长度：\\n”); scanf(“%d”,&amp;m); slink *h[m]; creat(h,m,m); display(h,m); search(h,m); return 0;} 实验内容1．闭散列表（也称开地址方法）查找的实现2．开散列表（也称拉链法）查找的实现 1：该实验的目的为“闭散列表（也称开地址方法）查找的实现”，所以我选择建立一个数组来保存关键字，散列函数构造用了除留余数法，并设置表长与除数一致，其中又选择了线性探测再散列的方法解决冲突。2：该实验的目的为散列表（也称拉链法）查找的实现，在实验中我曾定义了一个结构体指针变量传给结构体指针数组，导致溢出，编译和结果没问题但是出现return value 3221225477，更改之后一切正常了。","categories":[],"tags":[]}],"categories":[],"tags":[]}