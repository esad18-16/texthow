{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://gitee.com/e18-16/texthow","root":"/texthow/"},"pages":[],"posts":[{"title":"题目记录","slug":"题目记录","date":"2020-10-26T00:38:38.000Z","updated":"2020-10-26T11:32:01.712Z","comments":true,"path":"2020/10/26/题目记录/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/26/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"题目描述 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数示例1输入6输出2代码实现如下： #include &lt;stdio.h&gt;int main(void){ int data; int count=0; scanf(“%d”,&amp;data); while(data) { count ++; data=data&amp;(data-1); } printf(“%d”, count); return 0;} 思路：初始只考虑了将输入数转换为二进制数存入数组，再一一检查数组中1的个数，既耗内存又耗时间。后来在网上查找其他解决方法，才知道位运算可以轻松解决这个问题。 实现文件读写操作文件写入后需要用rewind()函数使文件指针回到文件开头，不然后续的读入操作将会受影响。 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void){ FILE *fp; int num; int i; fp=fopen(“D:\\testfile.txt”,”wb+”); if(fp==NULL) { system(“color 2C”); printf(“Error!!!\\n”); } else { for(i=0;i&lt;5;i++) { scanf(“%d”,&amp;num); fprintf(fp,”%4d”,num); } } int s=0; rewind(fp); for(i=0;i&lt;5;i++) { if(1==fscanf(fp,”%d”,&amp;s)) printf(“%4d”,s); else { system(“color 47”); printf(“Error!!!\\n”); } } return 0; } 蓝桥杯b组2、3题：2既约分数:#include&lt;stdio.h&gt;int gongyue(int a,int b){ int i,min; if(a&gt;b) min=b; else min=a; for(i=min;i&gt;0;i–) { if((a%i==0)&amp;&amp;(b%i==0)) break; } return i;}int main(void){ int i=1; int num=0; for(;i&lt;=2020;i++) { int j=1; for(;j&lt;=2020;j++) { if(gongyue(i,j)==1) num++; } } printf(“%d”,num); return 0;} 3蛇形填数:#include&lt;stdio.h&gt;int main(void){ int i=1; int j=0; int a[50][50]; a[0][0]=1; a[0][1]=2; a[1][0]=3; for(int num=3;num&lt;50*25;) { if(i==0&amp;&amp;j!=0) { a[i][j+1]=a[i][j]+1; j++; num++; } if(j==0&amp;&amp;i!=0) { a[i+1][j]=a[i][j]+1; i++; num++; } if(i!=0&amp;&amp;j==0) { while(i!=0) { a[i-1][j+1]=a[i][j]+1; i–; j++; num++; } continue; } if(i==0&amp;&amp;j!=0) { while(j!=0) { a[i+1][j-1]=a[i][j]+1; i++; j–; num++; } continue; } } printf(“%d\\n”,a[19][19]); return 0;}","categories":[],"tags":[]},{"title":"First blog","slug":"The-First-blog","date":"2020-10-19T07:53:43.196Z","updated":"2020-10-26T11:10:27.716Z","comments":true,"path":"2020/10/19/The-First-blog/","link":"","permalink":"https://gitee.com/e18-16/texthow/2020/10/19/The-First-blog/","excerpt":"散列表查找操作","text":"散列表查找操作 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10 //最大存储单元数typedef int keytype;typedef keytype HTable[MAXSIZE]; void creatHT(HTable HT,int m,int p){ int i,n=0; //n记录散列表中的元素个数 keytype x; //x存放关键字 printf(“请输入关键字(-999为结束输入数，最大存储单元为10)：\\n”); scanf(“%d”,&amp;x); while(x!=-999&amp;&amp;i&lt;MAXSIZE+1) { n++; if(n&gt;m) break; i=x%p; while(HT[i]!=-999) //判断是否有冲突,有则进行线性探测 i=(++i)%m; HT[i]=x; scanf(“%d”,&amp;x); }} void display(HTable HT,int m){ int i,j=0; for(i=0;i&lt;MAXSIZE;i++) //先输出地址便于查看 { if(i==0) printf(“ 地址：”); printf(“%4d”,i); } printf(“\\n”); for(i=0;i&lt;MAXSIZE;i++) //输出关键字 { if(i==0) printf(“关键字：”); if(HT[i]!=-999) { printf(“%4d”,HT[i]); j++; } else printf(“ “); if(j==m) break; } printf(“\\n”);} void search(HTable HT,int m,int p){ int i,j,x,s=0; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; j=i; while(HT[j]!=-999) { if(HT[j]==x) { printf(“关键字已找到，在数组中的下标为%d\\n”,j); s++; } //找到后输出j j=(j+1)%m; if(j==i) break; //没找到退出循环 } if(s==0) printf(“表中没有该关键字！\\n”);} int main(void){ HTable HT; int i; printf(“请先创建哈希表：\\n”); for(i=0;i&lt;MAXSIZE;i++) //初始化散列表 HT[i]=-999; creatHT(HT,MAXSIZE,MAXSIZE); display(HT,MAXSIZE); search(HT,MAXSIZE,MAXSIZE); return 0;} 四、2：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int key;typedef struct node{ key data; //存放关键字 struct node *next;}slink; void creat(slink *h[],int m,int p) //m为表长，p为除数{ int i; key x; slink *s; for(i=0;i&lt;m;i++) //初始化 h[i]=NULL; printf(“请输入关键字(-999为结束输入数)：\\n”); scanf(“%d”,&amp;x); while(x!=-999) { i=x%p; s=(slink *)malloc(sizeof(slink)); s-&gt;data=x; s-&gt;next=h[i]; //首插法 h[i]=s; scanf(“%d”,&amp;x); } } void display(slink *h[],int m){ int i; slink *s; printf(“地址 关键字\\n”); //控制输出格式便于观看 for(i=0;i&lt;m;i++) { printf(“%-4d “,i); s=h[i]; for(;s;s=s-&gt;next) printf(“%-4d”,s-&gt;data); printf(“\\n”); }} void search(slink *h[],int p){ slink *q; int i,j=0; key x; printf(“请输入想要查找的关键字：\\n”); scanf(“%d”,&amp;x); i=x%p; q=h[i]; while(q) { if(q-&gt;data==x) { printf(“关键字已找到,在下标为%d的链表中\\n”,i); j++; break; } q=q-&gt;next; } if(j==0) { printf(“未找到！！！\\n”); }} int main(void){ int m; printf(“请先创建哈希表：\\n”); printf(“请输入关键字长度：\\n”); scanf(“%d”,&amp;m); slink *h[m]; creat(h,m,m); display(h,m); search(h,m); return 0;} 实验内容1．闭散列表（也称开地址方法）查找的实现2．开散列表（也称拉链法）查找的实现 1：该实验的目的为“闭散列表（也称开地址方法）查找的实现”，所以我选择建立一个数组来保存关键字，散列函数构造用了除留余数法，并设置表长与除数一致，其中又选择了线性探测再散列的方法解决冲突。2：该实验的目的为散列表（也称拉链法）查找的实现，在实验中我曾定义了一个结构体指针变量传给结构体指针数组，导致溢出，编译和结果没问题但是出现return value 3221225477，更改之后一切正常了。","categories":[],"tags":[]}],"categories":[],"tags":[]}